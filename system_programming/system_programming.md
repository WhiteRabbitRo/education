# Курс "Системное программирование" (VK Education)

- [ ] Love R., "Linux Kernel Development" 
- [ ] Stevens R., "Advanced Programming in the UNIX Environment"

## Лекция 1 - "Введение"

Unix-like системы отличаются от остальных работой с файловой системой (файловые дискрипторы, "все-как-файл"), сетью и т.д.

Multics - прародитель Unix, где были:
- унифицирована память процессов
- введена динамическая линковка
- введена возможность изменять настройки аппаратного обеспечения в рантайме
- введен Shell (интерпретатор командной строки)
- введено понятие "колец безопасности"
- появилась иерархическая файловая система (папка в папке)

> PIC - Position Independent Code, машинный код не зависит от того, в какое адресное простанство он попадает

> Кольцо безопасности - концепция логической структуру программного обеспечения, где уровень ближе к ядру является более привелегированным

> Гипервизор - позволяет запускать множество систем на одном ядре (уровень -1)

> POSIX - стандарт интерфейсов UNIX

> Linux - в первую очередь ядро, а не полноценная операционная система

Ядра могут быть микро и монолитными:
- Микро-ядра более надежные, состоят из независимых подсистем, где сбой одной не приведет к сбою всей системы, однако они крайне непроизводительны (из за очереди сообщений между процессами).
- Монолитное ядро - один большой процесс с одним адрессным пространством, где может быть несколько динамических библиотек.

Пользователь может обращаться к ядру через system calls (syscall). Количество syscall'ов отличается от системы к системе.

Стандарты, например, POSIX, позволяют использовать унифицированные интерфейсы с индивидуальной имплементацией функционала под конкретную систему.

> UNIX - более ничего не называется, это старая операционная система. Все остальные системы могут быть UNIX-like.

## Лекция 2 - "Ядро Linux. Шедулинг процессов"

Операционная система - это менеджер устройств, включающий минимальный набор компонентов, необходимый для работы со всеми компонентами в целом. Ядро - часть операционной системы.

Есть два пространства:
- Пространство ядра (kernel space)
- Пространство пользователя (user space)

Пользовательский код может получать доступ к ядру. Это делается через системные вызовы (system calls). Это функция, которая вызывается в процессе пользовательском, а выполняется в процессе ядра.

> printf - это не системный вызов, но внутри может вызвать syscall "write"

Еще одна задача ядра - прерывания. Сигнал, приходящий на процессор и вызывающий остановку процесса, перекладывая задачу на обработчик прерывания. Прерывания могут образовывать очередь и вызываться последовательно.

У прерывания нет контекста, т.е. это просто электрический сигнал. Он не дает информации, кто и как вызвал прерывание.

Режимы:
- пользовательский
- ядра
- прерывания

Все прерывания образуют стэк, создаваемый перед запуском процесса.

Процессор знает, на какие PIN'ы приходит прерывания, в связи с чем он понимает, какое из устройств вызвало прерывание.

Паралеллизм прерываний заключается в том, что обработчик создает задачу для обработки прерывания для процессора, которая выполняется уже в ином режиме, нежели в режиме прерывания. 

> Top half - быстрая начальная обработка прерывания, bottom half - нижняя обработка.

Ядро запускается bootloader'ом. Эта программа ищет ядра и запускает исполняемый файл ядра нужной системы.

При запуске компьютера процессор обнаруживает, что он является пустым и запускает программу, которая ищет BIOS и запускает его, т.е. делает jump на адрес, где хранится BIOS (это адрес заранее известен).

BIOS находится в Read-Only Memory. Он способен работать с аппаратным обеспечением до запуска ОС. BIOS запускает все необходимые устройства, а далее находит bootloader и передает управление ему. 

Master Boot Record хранит адрес bootloader'а. Этот адрес известен BIOS заранее. 

Сам загрузчик ОС хранится уже на диске. Он сканирует файловую систему, ищет ядро и запускает его, подгружая его в оперативную память.

```
CPU --> BIOS --> bootloader --> kernel
```

Модули ядра:
- Процессы
- Аппаратное обеспечением (драйверы)
- Время
- Файловые системы
- IPC (доменные сокеты, очередь сообщений)
- Сеть (реализация протоколов)
- Пользователи (доступ, пароли, маски доступа)
- Структуры данных (списки, хэш таблицы)
- Виртуализация

### Управлением процессами в ядре

Процесс - единица исполнения программного кода. Имеет ресурсы (открытые файлы, оперативная память). Может быть разбит на потоки. Имеет идентификатор (PID).

Жизненный цикл процесса: создается через fork в режиме ожидания, далее запускается на каком то ядре процессора, далее перестает исполняться и становится снова в режиме ожидания.

Процесс может шедулиться, а может ждать, когда его вызовут. Во втором случае процессы потребляют мало ресурсов, не нагружают шедуллер, не занимают процессорное время, только занимают память и просто ждут вызова.

> **В ядре нет понятий процессов и потоков, но есть понятие задач. В пользовательском пространстве нет понятия задач, есть только процессы и потоки.**

> Ядро шедулит только потоки (задачи), оно не шедулит процессы.

### Управление аппаратным обеспечением в ядре

Драйверы подгружаются как динамическая библиотека. 

Драйверы не устанавливаются под каждое конкретное устройство, а имеют стандарт общего интерфейса, под который производитель устройства будет создавать его. Ядро не парится, с каким устройством оно работает, ему представляется только интерфейс.

> Под интерфейсом понимается структура с указателями на функции.

### Система времени в ядре

Ядро использует устройство, подключенное к материнской плате, для получения физического времени. Оно посылает сигнал прерывания, чтобы ядро увеличило счетчик тиков. 

Количество прерываний в секунду - настраиваемая величина. Но оно требует ресурсов, поэтому есть физическое ограничение на высокую частоту прерывания. 

Real Time Clock - устройство с осцилятором и батарейкой для хранения текущего времени. Оно продолжает работать даже когда система выключена.

> Активное ожидание - ожидание процесса без ухода в sleep. BogoMIPS - количество фейковых инструкций, которые процессор может выполнить за единицу времени. 

Синхронизация хода времени происходит с помощью PPS - устройство, измеряющее вибрацию атома цезия-133. Синхронизация идет за счет притормаживания realtime, а не шагов назад.

Время:
- Realtime - может идти назад
- Monotonic - не может идти назад

### Виртуальная файловая система

Файловые системы поддерживаются через интерфейсы аналогично драйверам. Для этого используется виртуальная файловая система (структура с указателями на функции).

> IO шедулер - для упорядочивания операций с файлами

### IPC

IPC - способы взаимодействия процессов в одной системе (не через файлы или диск).

### Подсистема работы с сетями

Подсистема включает реализацию протоколов, драйверов, стек TCP/IP, маршрутизации.

### Управление пользователями

Включает в себя структуру credentials - идентификаторы пользователей, группы, права доступа (маска). Используется для определенных процессов.

### Система структур данных

Система включает оптимальную реализацию структур данных, таких как связный список, хэш таблицы и т.д.

### Шедулинг процессов (тасков)

Шедулер (Scheduler) разделяет процессорное время по потокам так, что создается ощущение параллельности работы задач, поскольку ядро берет последовательно задачи и переключает их очень быстро. 

Кооперативный тип - задача сама решает, сколько она будет работать на ядре.

Вытесняющий тип - задача не имеет возможности решать, когда ее вытеснят другой.

> Корутины - кооперативная многозадачность. Их можно написать в пользовательском пространстве.

Задачи делятся на:
- IO Bound - скорость реакции (сеть, работа с диском) - задача долго ждет, но ее нужно резко выполнить
- CPU Bound - время процессора (обработка информации, вычисления) - задача должна выполняться долго, ей нужно больше времени выполнения

> Пользователь - это IO Bound

Шедулер должен уметь классифицировать задачи по этим двум видам.

В Си можно отдавать приоритеты потокам.

```C
int nice(int inc); // - чем выше, тем меньше приоритет таски
```

В Linux для каждой задачи выделяется не время, а процент использования процессорного времени в равной степени. 

Идеальный шедулер - переключаются задачи бесконечно часто. Это невозможно, поскольку на переключение тоже тратится время. 

CFS в реальности вычисляет пропорции:
$ W_i = \dfrac{1024}{1.25^{nice}} ; P_j = \dfrac{W_i}{\sum_{i=1}^{n} W_i} $

> Процессы в ожидании не находятся в шедулере. 
